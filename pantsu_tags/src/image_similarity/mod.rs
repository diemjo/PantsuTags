use std::collections::HashSet;
use std::hash::{Hash, Hasher};
use std::path::PathBuf;

mod similarity;

pub use similarity::group_similar_images;
use crate::ImageHandle;

pub trait NamedImage {
    /// Returns the name generated by crate::file_handler::hash::calculate_fileinfo()
    fn get_name(&self) -> &str;
}


/// Group of images that are similar to each other
pub struct SimilarImagesGroup<'a> {
    /// Images that will be newly added
    pub new_images: HashSet<&'a ImageToImport>,
    /// Images that are present in PantsuTags
    pub old_images: HashSet<&'a ImageHandle>,
}

impl<'a> SimilarImagesGroup<'a> {
    pub(crate) fn new() -> Self {
        Self {
            new_images: HashSet::new(),
            old_images: HashSet::new(),
        }
    }

    pub fn is_single_image(&self) -> bool {
        self.new_images.len() == 1 && self.old_images.is_empty()
    }
}

#[derive(Debug)]
pub struct ImageToImport {
    pub current_path: PathBuf,
    pub image_handle: ImageHandle,
    pub res: (u32, u32)
}

impl NamedImage for ImageToImport {
    fn get_name(&self) -> &str {
        self.image_handle.get_name()
    }
}
impl Hash for ImageToImport {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.image_handle.hash(state)
    }
}
impl PartialEq for ImageToImport {
    fn eq(&self, other: &Self) -> bool {
        self.image_handle == other.image_handle
    }
}
impl Eq for ImageToImport {}
